"""惡意程式清除腳本

此模組依據 `Read_First` 中的規範實作，透過下列步驟守護主機：
1. 偵測來自 `IntelSoftwareAgentTask` 目錄的 `node.exe`
2. 結束可疑行程、移除資料夾
3. 掃描雲端硬碟同步資料夾中的可疑檔案
4. 將過程詳細寫入同名 `.log` 以利追蹤
"""

from __future__ import annotations

import ctypes
import os
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Set

SUSPECT_PATH = Path(r"C:\Windows\System32\IntelSoftwareAgentTask")
LOG_PATH = Path(__file__).with_suffix(".log")

# 可疑檔案名稱模式（用於雲端硬碟掃描）
SUSPECT_FILE_PATTERNS = {
    "node.exe",
    "IntelSoftwareAgentTask",
    "0.vlejh9qig7k.node",
    "app.js",
    "build.zip",
    "preload.js",
    "winpty-agent.exe",
}

# 常見雲端硬碟路徑（會自動偵測使用者名稱）
CLOUD_DRIVE_NAMES = [
    "OneDrive",
    "Google Drive",
    "GoogleDrive",
    "Dropbox",
    "iCloudDrive",
    "Box",
]


def is_admin() -> bool:
    """檢查目前程序是否擁有系統管理員權限。"""
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()  # type: ignore[attr-defined]
    except Exception:  # noqa: BLE001
        return False


def append_log(message: str) -> None:
    """將訊息寫入 log 並同步輸出在終端。"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    line = f"[{timestamp}] {message}\n"
    with LOG_PATH.open("a", encoding="utf-8") as handle:
        handle.write(line)
    print(line, end="")


def list_node_processes() -> List[Dict[str, str]]:
    """使用 WMIC 取得所有 node.exe 相關資訊。"""
    try:
        result = subprocess.run(
            [
                "wmic",
                "process",
                "where",
                "name='node.exe'",
                "get",
                "ProcessId,ExecutablePath",
                "/format:list",
            ],
            capture_output=True,
            text=True,
            check=True,
        )
    except subprocess.CalledProcessError as exc:
        append_log(f"Failed to query node.exe processes: {exc}")
        return []

    entries: List[Dict[str, str]] = []
    for block in result.stdout.strip().split("\n\n"):
        if not block.strip():
            continue
        info = {
            key: value
            for key, value in (
                line.split("=", 1) for line in block.strip().splitlines() if "=" in line
            )
        }
        entries.append(info)
    return entries


def kill_process(pid: str, path: str) -> None:
    """強制終止指定 PID，並回報其執行檔路徑。"""
    try:
        subprocess.run(["taskkill", "/PID", pid, "/F"], check=True, capture_output=True)
        append_log(f"Terminated node.exe PID {pid} (path={path or 'unknown'})")
    except subprocess.CalledProcessError as exc:
        append_log(f"Failed to terminate PID {pid}: {exc}")


def remove_suspect_directory() -> None:
    """刪除可疑資料夾並記錄結果。"""
    if not SUSPECT_PATH.exists():
        append_log(f"{SUSPECT_PATH} not found. Nothing to remove.")
        return
    try:
        shutil.rmtree(SUSPECT_PATH)
        append_log(f"Removed directory {SUSPECT_PATH}")
    except PermissionError as exc:
        append_log(f"Permission denied removing {SUSPECT_PATH}: {exc}")
    except Exception as exc:  # noqa: BLE001
        append_log(f"Unexpected error removing {SUSPECT_PATH}: {exc}")


def scan_for_respawn() -> None:
    """再次檢查資料夾是否復活，並列出其中內容。"""
    if SUSPECT_PATH.exists():
        items = list(SUSPECT_PATH.glob("*"))
        append_log(f"WARNING: {SUSPECT_PATH} reappeared with {len(items)} items")
        for item in items:
            append_log(f" - {item}")
    else:
        append_log(f"{SUSPECT_PATH} remains absent after cleanup.")


def find_cloud_drive_paths() -> List[Path]:
    """自動偵測使用者雲端硬碟同步資料夾路徑。"""
    user_home = Path.home()
    cloud_paths: List[Path] = []
    
    for drive_name in CLOUD_DRIVE_NAMES:
        potential_path = user_home / drive_name
        if potential_path.exists() and potential_path.is_dir():
            cloud_paths.append(potential_path)
            append_log(f"Found cloud drive: {potential_path}")
    
    # 也檢查 OneDrive 的企業版路徑（格式：C:\Users\<username>\OneDrive - <Company>）
    for potential_onedrive in user_home.parent.glob("OneDrive - *"):
        if potential_onedrive.is_dir():
            cloud_paths.append(potential_onedrive)
            append_log(f"Found OneDrive Business: {potential_onedrive}")
    
    return cloud_paths


def scan_cloud_drive_for_suspect_files(cloud_path: Path, max_depth: int = 3) -> List[Path]:
    """遞迴掃描雲端硬碟資料夾，找出可疑檔案。
    
    Args:
        cloud_path: 雲端硬碟根目錄路徑
        max_depth: 最大掃描深度（避免掃描過深）
    
    Returns:
        找到的可疑檔案路徑列表
    """
    found_files: List[Path] = []
    
    def _scan_recursive(current_path: Path, depth: int) -> None:
        """內部遞迴掃描函數。"""
        if depth > max_depth:
            return
        
        try:
            for item in current_path.iterdir():
                # 檢查檔案名稱是否匹配可疑模式
                item_name_lower = item.name.lower()
                if any(pattern.lower() in item_name_lower for pattern in SUSPECT_FILE_PATTERNS):
                    found_files.append(item)
                    append_log(f"⚠️  Found suspect file in cloud drive: {item}")
                
                # 如果是資料夾且未達深度限制，繼續遞迴
                if item.is_dir() and depth < max_depth:
                    # 跳過系統資料夾和隱藏資料夾
                    if not item.name.startswith('.') and item.name not in ['node_modules', '__pycache__']:
                        _scan_recursive(item, depth + 1)
        except PermissionError:
            append_log(f"Permission denied accessing: {current_path}")
        except Exception as exc:  # noqa: BLE001
            append_log(f"Error scanning {current_path}: {exc}")
    
    _scan_recursive(cloud_path, 0)
    return found_files


def remove_suspect_files_from_cloud(found_files: List[Path]) -> None:
    """嘗試刪除雲端硬碟中找到的可疑檔案。"""
    for file_path in found_files:
        try:
            if file_path.is_file():
                file_path.unlink()
                append_log(f"✓ Removed suspect file: {file_path}")
            elif file_path.is_dir():
                shutil.rmtree(file_path)
                append_log(f"✓ Removed suspect directory: {file_path}")
        except PermissionError as exc:
            append_log(f"✗ Permission denied removing {file_path}: {exc}")
        except Exception as exc:  # noqa: BLE001
            append_log(f"✗ Failed to remove {file_path}: {exc}")


def main() -> None:
    """腳本進入點：依循流程執行清除作業（包含雲端硬碟掃描）。"""
    append_log("--- Malware cleanup session started ---")
    if not is_admin():
        append_log("Script is NOT running as administrator. Actions may fail.")

    # 步驟 1: 處理系統目錄中的惡意程式
    processes = list_node_processes()
    suspect = []
    for proc in processes:
        exe_path = proc.get("ExecutablePath", "") or ""
        normalized = exe_path.replace("\\", "/").lower()
        if SUSPECT_PATH.as_posix().lower() in normalized:
            suspect.append(proc)

    append_log(
        f"Detected {len(processes)} node.exe process(es); "
        f"{len(suspect)} originated from the suspect path."
    )

    for proc in suspect:
        kill_process(proc.get("ProcessId", ""), proc.get("ExecutablePath", ""))

    if not suspect:
        append_log("No suspicious node.exe processes required termination.")

    remove_suspect_directory()
    scan_for_respawn()

    # 步驟 2: 掃描雲端硬碟同步資料夾
    append_log("--- Starting cloud drive scan ---")
    cloud_paths = find_cloud_drive_paths()
    
    if not cloud_paths:
        append_log("No cloud drive folders detected. Skipping cloud scan.")
    else:
        all_found_files: List[Path] = []
        for cloud_path in cloud_paths:
            append_log(f"Scanning cloud drive: {cloud_path}")
            found = scan_cloud_drive_for_suspect_files(cloud_path, max_depth=3)
            all_found_files.extend(found)
        
        if all_found_files:
            append_log(f"⚠️  Found {len(all_found_files)} suspect file(s) in cloud drives")
            append_log("Attempting to remove suspect files from cloud drives...")
            remove_suspect_files_from_cloud(all_found_files)
        else:
            append_log("✓ No suspect files found in cloud drives.")
    
    append_log("--- Malware cleanup session completed ---")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)

